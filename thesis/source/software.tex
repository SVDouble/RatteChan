% !TeX spellcheck = en_US


\chapter{Control Algorithms}


\section{Overview}

The goal of the whisker control is to reconstruct the contour of an object the whisker came into contact by swiping along its curve.
This requires an algorithm with the following properties:
\begin{enumerate}
    \item It enables the whisker to precisely reconstruct the contour of the object at the immediate contact point.
    \item It can accurately follow the curves and sharp angles of the object, while maintaining the optimal whisker deflection.
    \item It can handle whisker detachment due to sharp angles or sudden changes in the object's surface.
    \item It is aware of the dimensions of the platform and can avoid collisions with the object.
\end{enumerate}

To realize these properties, the control algorithm is implemented as a finite state machine.
Different states handle semantically different aspects of the whisker's behavior.
The behavior of the control is divided into policies that are executed sequentially based on the environment's state.
In this thesis, three policies are implemented:
\begin{enumerate}
    \item \textbf{Swiping Policy:} The whisker is swiping along a smooth curve, maintaining an optimal deflection profile.
    \item \textbf{Retrieval Policy:} The whisker quickly retrieves the object if it has become detached and continues swiping along the profile.
    \item \textbf{Tunnelling Policy:} Given two walls, shaped like a tunnel, the platform maintains centering between the walls.
\end{enumerate}


\section{Data Preprocessing}

\subsection{Control Algorithm Variables}

It is necessary to consider the variables of the control algorithm.
The inputs come from 3 sources:
\begin{enumerate}
    \item Sensors on the platform (provide the platform's position, orientation and whisker deflection).
    \item The geometric configuration of the model (e.g., whisker placement).
    \item The control algorithm's configuration (e.g., whisker deflection threshold).
\end{enumerate}
The output variables concerns the target linear and angular velocities of the platform.
The variables are summarized in Table~\ref{tab:variables}.

\newcommand{\branch}[3]{%
    \scalebox{0.75}{$\left\{
                         \begin{array}{@{}l@{\quad}l@{}}
                             #2, & \text{if } #1,\\[0.5em]
                             #3, & \text{otherwise.}
                         \end{array}
    \right.$}%
}


\begin{table}[htb]
    \centering
    \begin{tabular}{p{1cm} p{2cm} p{3cm} p{8cm}}
        \toprule
        \textbf{Name}                                        & \textbf{Values}                                                   & \textbf{Source}                                         & \textbf{Description}                                                                                                        \\
        \midrule
        \multicolumn{4}{l}{\textbf{Platform Inputs}} \\
        \midrule
        \(^{\mathrm{w}}\boldsymbol{r}^{t}\)                  & \(\mathbb{R}^2, [x, y]^\mathrm{T}\)                               & Measured                                                & Radius vector in world coordinates.                                                                                         \\
        \(^{\mathrm{w}}\alpha^{t}\)                          & \(\mathbb{R}\)                                                    & Measured                                                & Yaw angle (orientation) in world coordinates.                                                                               \\
        \(v_{\mathrm{total}}\)                               & \(\mathbb{R}^{+}\)                                                & Configuration                                           & Total platform velocity.                                                                                                    \\
        \midrule
        \multicolumn{4}{l}{\textbf{Platform Outputs}} \\
        \midrule
        \(^{\mathrm{w}}\boldsymbol{v}^{t}\)                  & \(\mathbb{R}^2, [v_x, v_y]^\mathrm{T}\)                           & Controlled                                              & Linear velocity vector in world coordinates.                                                                                \\
        \(^{\mathrm{w}}\omega^{t}\)                          & \(\mathbb{R}^2\)                                                  & Controlled                                              & Angular velocity (yaw) in world coordinates.                                                                                \\
        \midrule
        \multicolumn{4}{l}{\textbf{Whisker Inputs (per whisker)}} \\
        \midrule
        \(\delta_{i}^{t}\)                                   & \([-\delta_{\mathrm{i, \mathrm{max}}},\delta_{i, \mathrm{max}}]\) & Measured                                                & Deflection due to contact forces.                                                                                           \\
        \(\alpha_{i}^{t}\)                                   & \(\mathbb{R}\)                                                    & \(^{\mathrm{w}}\alpha^{t} + \alpha_{i, \mathrm{body}}\) & Yaw angle (orientation) of the whisker base in world coordinates.                                                           \\
        \(orient_{i}^{t}\)                                   & \(\{-1, 0, 1\}\)                                                  & \(sgn(\delta_{i}^{t}) \cdot side_{i}\)                  & Valid swipe orientation with current deflection: \(-1\) for clockwise, \(0\) for undefined, and \(1\) for counterclockwise. \\
        \(side_{i}\)                                         & \(\{-1, 1\}\)                                                     & \(\branch{\alpha_{i,\mathrm{body}} < 0}{-1}{1}\)        & Platform side where the whisker is fixed, -1 is left and 1 is right                                                         \\
        \(\delta_{i, \mathrm{thr}}\)                         & \(\mathbb{R}^{+}\)                                                & Deflection Model                                        & Deflection threshold value for contact detection (\(\delta_{i, \mathrm{thr}}\ll\delta_{i, \mathrm{max}}\)).                 \\
        \(\delta_{i, \mathrm{target}}\)                      & \([-\delta_{\mathrm{i, max}},\delta_{i, \mathrm{max}}]\)          & Deflection Model                                        & Target deflection value for small reconstruction error.                                                                     \\
        \(\;^{\mathrm{w}}\boldsymbol{r}_{i, \mathrm{body}}\) & \(\mathbb{R}^2\)                                                  & Robot Geometry                                          & Offset from the platform center to the whisker base.                                                                        \\
        \(\alpha_{i, \mathrm{body}}\)                        & \([-\pi,\pi)\)                                                    & Robot Geometry                                          & Angle for whisker placement relative to the platform.                                                                       \\
        \bottomrule
    \end{tabular}
    \caption{Overview of input and output variables used in the control system.}
    \label{tab:variables}
\end{table}

\subsection{Deflection Smoothing}
The measured whisker deflection \(\delta_{i}^{t}\) is inherently noisy, as whiskers are subject to vibrations and jumps (e.g., due to being temporarily stuck because of the traction).
To smooth the deflection, a Butterworth filter is applied to the deflection values.
It is initially warmed up with the neutral deflection and then updated with each new measurement.


\section{Body Motion Control}
All the control policies calculate the desired body or whisker position, which is then executed by the platform's actuators.
In order for the body to move properly, the body motion algorithm must calculate the required velocities to reach the desired position.
A PID controller is employed to calculate the target platform angular velocity.
To simplify the control, the linear velocity is kept constant, and therefore the velocity vector can be directly derived from the desired angle, see Algorithm~\ref{alg:steer_platform}.
In some cases body motion controller received the target position for the whisker instead of the body.
In this case, the body linear velocity is adjusted for the coordinate transformation from the whisker to the body frame, as shown in Algorithm~\ref{alg:steer_whisker}.

\begin{algorithm}[htb]
    \caption{Steer the Platform to Target Position and Orientation}
    \begin{algorithmic}
        \State Require \(^{\mathrm{w}}\boldsymbol{r}^{t+1}\), \(\;^{\mathrm{w}}\alpha^{t+1}\)
        \State \(^{\mathrm{w}}\omega^{t+1} \gets \mathrm{PID}(\;^{\mathrm{w}}\alpha^{t+1} - \;^{\mathrm{w}}\alpha^{t})\)
        \State \(^{\mathrm{w}}\boldsymbol{v}^{t+1} \gets v_{\mathrm{total}} \cdot \dfrac{^{\mathrm{w}}\boldsymbol{r}^{t+1}}{\|^{\mathrm{w}}\boldsymbol{r}^{t+1}\|}\)
        \State Return \(^{\mathrm{w}}\boldsymbol{v}^{t+1}\), \(^{\mathrm{w}}\omega^{t+1}\)
    \end{algorithmic}
    \label{alg:steer_platform}
\end{algorithm}

\begin{algorithm}[htb]
    \caption{Steer Whisker to Target Position and Orientation}
    \begin{algorithmic}
        \State Require \(^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk}}^{t+1}\), \(^{\mathrm{w}}\alpha_{\mathrm{wsk}}^{t+1}\)
        \State \((^{\mathrm{w}}\boldsymbol{v}^{t+1},\, ^{\mathrm{w}}\omega^{t+1}) \gets \mathrm{steer\_body}(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk}}^{t+1},\, ^{\mathrm{w}}\alpha_{\mathrm{wsk}}^{t+1})\)
        \State \(^{\mathrm{w}}\boldsymbol{r}_{\mathrm{corr}} \gets [0,\,0,\,^{\mathrm{w}}\omega^{t+1}] \times \boldsymbol{r}_{\mathrm{wsk, body}}\) \Comment{Correct for whisker offset (pivot shift)}
        \State \(^{\mathrm{w}}\boldsymbol{v}^{t+1} \gets v_{\mathrm{total}} \cdot \dfrac{^{\mathrm{w}}\boldsymbol{v}^{t+1} + \,^{\mathrm{w}}\boldsymbol{r}_{\mathrm{corr}}}{\|^{\mathrm{w}}\boldsymbol{v}^{t+1} + \,^{\mathrm{w}}\boldsymbol{r}_{\mathrm{corr}}\|}\)
        \State Return \(^{\mathrm{w}}\boldsymbol{v}^{t+1}\), \(^{\mathrm{w}}\omega^{t+1}\)
    \end{algorithmic}
    \label{alg:steer_whisker}
\end{algorithm}


\section{Swiping Policy}

The goal of the swiping policy is to provide a smooth swiping motion of the whisker along the object's contour.
At the same time, it is expected to collect high precision data about the object's shape.
In order to achieve this, the whisker must maintain an optimal deflection profile, as the error of the deflection model is usually dependent on the whisker's deflection.
All in all, this requires balancing between following the object's curvature and maintaining the target deflection.
For the contour following part, a spline is used to approximate the object's curve.
The spline is updated with each new whisker position, and the tangent at the end of the curve is used to calculate the desired whisker orientation.
To account for the whisker's deflection, the target whisker base-tip offset is calculated based on the deflection model, and compared to the target deflection.
The whisker's position is thus given as a weighted sum of the vector, which minimizes the deflection error, and the spline tangent.
For the transient effects, specifically when the whisker deflection is below a certain threshold or the spline couldn't have been built yet, the swiping policy preserves the last control values.

\begin{algorithm}[htb]
    \caption{Swiping Policy}
    \begin{algorithmic}
        \State If \(|\delta_{\mathrm{wsk}}^{t}| < \delta_{\mathrm{wsk, thr}}\) Then \Comment{Check that the whisker touches the object}
        \State \quad Return \(\;^{\mathrm{w}}\boldsymbol{v}^{t}\), \(\;^{\mathrm{w}}\omega^{t}\)
        \State End If
        \State
        \State \(\;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip}}^{t} \gets \mathrm{wsk.defl\_model}(\delta_{\mathrm{wsk}}^{t})\)
        \State \(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{tip}}^{t} \gets \;^{\mathrm{w}}\boldsymbol{r}^{t} + \;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk, body}} + \boldsymbol{R}_{xy}^{2}(\; ^{\mathrm{w}}\alpha_{\mathrm{wsk}}^{t}) \cdot \;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip}}^{t}\)
        \State \(\mathrm{wsk.spline.add\_keypoint}(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{tip}}^{t})\)
        \State If not \(\mathrm{wsk.spline.has\_enough\_points()}\) Then \Comment{Check that the spline is complete}
        \State \quad Return \(\;^{\mathrm{w}}\boldsymbol{v}^{t}\), \(\;^{\mathrm{w}}\omega^{t}\)
        \State End If
        \State
        \State \(\;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t} \gets \dfrac{\mathrm{wsk.spline}(u\mathord{=}u_{k1}) - \mathrm{wsk.spline}(u\mathord{=}u_{k0})}{\|\mathrm{wsk.spline}(u\mathord{=}u_{k1}) - \mathrm{wsk.spline}(u\mathord{=}u_{k0})\|}\) \Comment{Object surface tangent}
        \State \(\;^{\mathrm{w}}\theta_{\mathrm{spline}}^{t} \gets \mathrm{arctan2}(\;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t})\) \Comment{Object surface angle}
        \State \(\;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip, target}}^{t} \gets \mathrm{wsk.defl\_model}\big(\delta_{\mathrm{wsk, target}} \cdot \operatorname{sgn}(\delta_{\mathrm{wsk}}^{t})\big)\) \Comment{Desired whisker base-tip offset}
        \State \(\Delta\boldsymbol{r}_{tip}^{t} \gets \boldsymbol{R}_{xy}^{2}(\; ^{\mathrm{w}}\alpha_{\mathrm{wsk}}^{t}) \cdot (\;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip, target}}^{t} - \;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip}}^{t})\) \Comment{\((\forall{t} \;^{\mathrm{w}}\boldsymbol{v}^{t+1} \updownarrow \Delta\boldsymbol{r}_{\mathrm{tip}}^{t}) \implies \delta_{\mathrm{wsk}}^{t} \xrightarrow[t \to \infty]{} \delta_{\mathrm{wsk, target}}\) }
        \State \(\;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip, neutral}} \gets \mathrm{wsk.defl\_model}(0)\) \Comment{Undeformed whisker base-tip offset}
        \State \(w_{\mathrm{defl}}^{t} \gets \dfrac{\|\Delta\boldsymbol{r}_{\mathrm{tip}}^{t}\|}{\|\;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip, target}}^{t} - \;^{\mathrm{s}}\boldsymbol{r}_{\mathrm{tip, neutral}}\|}\) \Comment{Balance between following the object curvature...}
        \State \(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk}}^{t+1} \gets \;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk}}^{t} + w_{\mathrm{defl}}^{t} \cdot \dfrac{-\Delta\boldsymbol{r}_{\mathrm{tip}}^{t}}{\|\Delta\boldsymbol{r}_{\mathrm{tip}}^{t}\|} + (1 - w_{\mathrm{defl}}^{t}) \cdot \dfrac{\;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t}}{\|\;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t}\|}\) \Comment{...and maintaining \(\delta_{\mathrm{wsk, target}}\)}
        \State
        \State
        \State \((\;^{\mathrm{w}}\boldsymbol{v}^{t+1}, \;^{\mathrm{w}}\omega^{t+1}) \gets \mathrm{steer\_wsk}(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk}}^{t+1},\;^{\mathrm{w}}\theta_{\mathrm{spline}}^{t})\)
        \State Return \(\;^{\mathrm{w}}\boldsymbol{v}^{t+1}, \;^{\mathrm{w}}\omega^{t+1}\)
    \end{algorithmic}
    \label{alg:swiping_policy}
\end{algorithm}


\section{Retrieval Policy}

The goal of the retrieval policy is to retrieve the contact with the object if the whisker has become detached and smoothly continue from the last known position, while moving as little as possible and picking up the swiping as fast as possible.
There are two scenarios when the whisker can become detached:
1. Due to the object's surface: the angle of the curve is too sharp for the whisker to follow.
2. Due to slippage:
either (a) forward, when the angle becomes sharper, but not too sharp for it to become disengaged, also because of the traction, when the whisker gets stuck for a short time and the platform moves forward,
or (b) backward, when the deflection profile is not optimal and there is some build up tension in the whisker.

The largest challenge is to determine the actual object profile to be able to continue the navigation.
As the slippage is already cover by the swiping policy (small periods of no deflection are tolerable), here the focus is at the whisker detachment due to the object's surface.
The expected range of angle lies between angles near 10-20 degrees (the whisker already lies beyond the original surface tangent, as it was deflected and now assumes a neutral position) and 180 degrees.
Likely a test point at the other side of the edge is required to determine the actual angle of the edge, as the spline doesn't provide a reliable reference, as it is outdated and cannot be constructed in the absence of the contact.

Here's a brief overview of the retrieval policy we have been able to come up with:
\subsection{Premise}
If the whisker has been detached for longer than a certain threshold, it is considered disengaged.
After that the retrieval policy takes over from the swiping policy.

\subsubsection{Angle resolution}
The whisker determines and performs angle resolution strategy:
it targets the contact in a certain distance from the last known position (so called edge), geometrical place of all such points is a circle
for every point in the circle the whisker yaw as calculated, so that the whisker always stays at a predifened angle with the object's surface at the time of contact
Basically what happens is that the whisker moves back to a starting angle-detection position and then its base follows a cicle, while it keeps a constant angle to the radius vector between the whisker base and the edge

\subsection{Whisking back to the edge}
Once the contact has been restored, the whisker whisks back along the opposite edge, following directly the path between the detected point and the edge.
As the angle resolution strategy makes sure the whisker is at a predefined angle with the potential, surface at all times, no adjustments need to be made to the whisker's linear backward motion.
The radius is chosen in a way that this distance (contact point - edge) is enough to construct a new spline - and give a reliable prediction for the contour of the opposite side.

\subsection{Repositioning}
Once the opposite side has been grabbed and analyzed, the whisker detaches itself again, this time intentionally. Now it is back at the edge, and the target reengagement angle is know.
The whisker is repositioned in such a manner that it will have a slight overshoot over the angle at the reengagement time.

\subsection{Transition to swiping}
4 The whisker start swiping at the other side (it doesn't really matter whether the edge is sharp or smooth, as we have the overshoot to account for that).
After the spline has been constructed at this side, the whisking policy takes over. The maneuver has been completed.


\section{Tunneling Policy}

In the tunnel policy, the platform must maintain a centered trajectory between two surfaces, ensuring optimal whisker contact on both sides.
To achieve this, a midpoint spline is constructed using keypoints defined by the midpoint between the left and right whisker contacts.

\begin{algorithm}
    \caption{Tunneling Policy Control}
    \label{alg:tunneling_policy}
    \begin{algorithmic}
        \State If \(\delta_{\mathrm{wsk\_left}}^{t} < \delta_{\mathrm{wsk\_left}}^{\mathrm{thr}}\) Or \(\$\delta_{\mathrm{wsk\_right}}^{t} < \delta_{\mathrm{wsk\_right}}^{\mathrm{thr}}\) Then
        \State \quad Return \(\;^{\mathrm{w}}\boldsymbol{v}^{t}\), \(\;^{\mathrm{w}}\omega^{t}\)
        \State End If
        \State
        \State \(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{tip, wsk\_right}}^{t} \gets \;^{\mathrm{w}}\boldsymbol{r}^{t} + \;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk\_right, body}} + \boldsymbol{R}_{xy}^{2}(\; ^{\mathrm{w}}\alpha_{\mathrm{wsk\_right}}^{t}) \cdot \mathrm{wsk\_right.defl\_model}(\delta_{\mathrm{wsk\_right}}^{t})\)
        \State \(\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{tip, wsk\_left}}^{t} \gets \;^{\mathrm{w}}\boldsymbol{r}^{t} + \;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{wsk\_left, body}} + \boldsymbol{R}_{xy}^{2}(\; ^{\mathrm{w}}\alpha_{\mathrm{wsk\_left}}^{t}) \cdot \mathrm{wsk\_left.defl\_model}(\delta_{\mathrm{wsk\_left}}^{t})\)
        \State \(\mathrm{midpoint\_spline.add\_keypoint}\big((\;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{tip, wsk\_right}}^{t} + \;^{\mathrm{w}}\boldsymbol{r}_{\mathrm{tip, wsk\_left}}^{t}) / 2\big)\)
        \State If not \(\mathrm{midpoint\_spline.has\_enough\_points()}\) Then
        \State \quad Return \(\;^{\mathrm{w}}\boldsymbol{v}^{t}\), \(\;^{\mathrm{w}}\omega^{t}\)
        \State End If
        \State
        \State \(\;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t} \gets \mathrm{midpoint\_spline}(u\mathord{=}1) - \mathrm{midpoint\_spline}(u\mathord{=}0)\)
        \State \(\;^{\mathrm{w}}\theta_{\mathrm{spline}}^{t} \gets \mathrm{arctan2}(\;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t})\)
        \State
        \State \((\;^{\mathrm{w}}\boldsymbol{v}^{t+1}, \;^{\mathrm{w}}\omega^{t+1}) \gets steer\_body(\;^{\mathrm{w}}\boldsymbol{r}^{t+1} + \;^{\mathrm{w}}\boldsymbol{\tau}_{\mathrm{spline}}^{t},\;^{\mathrm{w}}\theta_{\mathrm{spline}}^{t})\)
        \State Return \(\;^{\mathrm{w}}\boldsymbol{v}^{t+1}, \;^{\mathrm{w}}\omega^{t+1}\)
    \end{algorithmic}
\end{algorithm}


\section{Finite State Machine}
The policies by themselves are quite specialized and only by using them in combination the whisker can harness their true power.
Such is handy to implement using a finite state machine.
Policies are represented by respective states and transition between happen when specific events occur, like "whisker has come into contact with the surface" and "whisker has become disengaged"
Here's the statechart of the finite state machine for the discussed policies:


\section{Additional features}
\subsection{Retrieval without edge reconstruction}
...
\subsection{Tilt}
...
\subsection{Reverse swiping}
...
\subsection{Positioning of whiskers at different angles}
...
\subsection{Integration of multiple whiskers on each side}
- precision of the surface resolution
- single shot swiping without need for retrieval
- active whisking
\subsection{Transition to SLAM and free exploration}

\section{Limitations of the suggested control algorithm}

\section{Comparison to the baseline}
The baseline from the previous works only has the swiping policy
This swiping policy employs a single PID controller that takes whisker deflection error as an input and returns the desired velocity of the platform in the direction of the object.
The idea is that in order to keep the whisker profile constant the deflection needs to be constant, and for that the body should move closer to the object when the whisker becomes too loose and away if it is too strained.
Albeit such an algorithm is suitable and works in a well defined scenarios, it has some inherent instabilities:
-
